# goit-algo-hw-04
Висновки.
На основі проведених емпіричних вимірювань продуктивності алгоритмів сортування можна сформулювати такі узагальнення:
1. Insertion Sort (Сортування вставками).
- Алгоритм демонструє квадратичну часову складність $О(n^2)$, що підтверджується експериментальними даними: зі збільшенням обсягу набору даних час виконання зростає надзвичайно швидко. 
- На масиві з 5000 елементів алгоритм працює у сотні–тисячі разів повільніше, ніж сортування злиттям або Timsort.
- Незважаючи на це, метод залишається ефективним для дуже малих списків або частково впорядкованих даних, де кількість операцій значно зменшується.
2. Merge Sort (Сортування злиттям).
- Реалізація сортування злиттям відповідає теоретичній складності $O(n \log n)$. 
- Алгоритм показує хорошу масштабованість і працює стабільно швидко для масивів будь-якого розміру.
- Використання рекурсивного розбиття та ефективного злиття дозволяє значно перевершувати сортування вставками на середніх і великих наборах даних.
3. Timsort (Вбудований алгоритм Python — sorted() / .sort()).
- За результатами тестів Timsort є найефективнішим серед розглянутих методів. 
- Його висока продуктивність пояснюється гібридною природою: алгоритм поєднує переваги сортування вставками для малих підмасивів та ефективність злиття для обʼєднання впорядкованих фрагментів. 
- Додатковою перевагою є адаптивність — алгоритм автоматично використовує властивості частково відсортованих даних, що значно підвищує швидкість на реальних наборах.